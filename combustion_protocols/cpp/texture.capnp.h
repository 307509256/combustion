// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: protocols\texture.capnp

#ifndef CAPNP_INCLUDED_a0647fd03678a3a6_
#define CAPNP_INCLUDED_a0647fd03678a3a6_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 5003
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(9a59cc24bdd96691);
enum class Rgtc_9a59cc24bdd96691: uint16_t {
  RED,
  RED_SIGNED,
  RG,
  RG_SIGNED,
};
CAPNP_DECLARE_ENUM(Rgtc, 9a59cc24bdd96691);
CAPNP_DECLARE_SCHEMA(e7862489f94a0af0);
enum class Bptc_e7862489f94a0af0: uint16_t {
  RGBA,
  RGB_FLOAT_SIGNED,
  RGB_FLOAT_UNSIGNED,
};
CAPNP_DECLARE_ENUM(Bptc, e7862489f94a0af0);
CAPNP_DECLARE_SCHEMA(b31f871133cef5fe);
enum class S3tc_b31f871133cef5fe: uint16_t {
  RGB1,
  RGBA1,
  RGBA3,
  RGBA5,
};
CAPNP_DECLARE_ENUM(S3tc, b31f871133cef5fe);
CAPNP_DECLARE_SCHEMA(a5b0498648f87aab);
enum class BlockSize_a5b0498648f87aab: uint16_t {
  B4X4,
  B5X4,
  B5X5,
  B6X5,
  B6X6,
  B8X5,
  B8X6,
  B10X5,
  B10X6,
  B8X8,
  B10X8,
  B10X10,
  B12X10,
  B12X12,
};
CAPNP_DECLARE_ENUM(BlockSize, a5b0498648f87aab);
CAPNP_DECLARE_SCHEMA(efac83628ed9c608);
enum class Channels_efac83628ed9c608: uint16_t {
  R,
  RG,
  RGB,
  RGBA,
};
CAPNP_DECLARE_ENUM(Channels, efac83628ed9c608);
CAPNP_DECLARE_SCHEMA(bf40f4217973ffde);
enum class DataType_bf40f4217973ffde: uint16_t {
  UNSIGNED_BYTE,
  BYTE,
  UNSIGNED_SHORT,
  SHORT,
  UNSIGNED_INT,
  INT,
  FLOAT,
  UNSIGNED_BYTE332,
  UNSIGNED_BYTE233_REV,
  UNSIGNED_SHORT565,
  UNSIGNED_SHORT565_REV,
  UNSIGNED_SHORT4444,
  UNSIGNED_SHORT4444_REV,
  UNSIGNED_SHORT5551,
  UNSIGNED_SHORT1555_REV,
  UNSIGNED_INT8888,
  UNSIGNED_INT8888_REV,
  UNSIGNED_INT1010102,
  UNSIGNED_INT2101010_REV,
  UNSPECIFIED,
};
CAPNP_DECLARE_ENUM(DataType, bf40f4217973ffde);
CAPNP_DECLARE_SCHEMA(fac0ea8b372b50ff);
CAPNP_DECLARE_SCHEMA(fc05632244f526d5);
enum class TextureKind_fc05632244f526d5: uint16_t {
  TEXTURE1_D,
  TEXTURE2_D,
  TEXTURE3_D,
};
CAPNP_DECLARE_ENUM(TextureKind, fc05632244f526d5);
CAPNP_DECLARE_SCHEMA(c4cf8d45880f89f2);
CAPNP_DECLARE_SCHEMA(c64972e0022dd9c5);
CAPNP_DECLARE_SCHEMA(f81d792693e6a6f3);
CAPNP_DECLARE_SCHEMA(9ff57f9fd9f83b0d);
CAPNP_DECLARE_SCHEMA(8630d6be0dfe5710);
CAPNP_DECLARE_SCHEMA(e778d2682349d8fc);

}  // namespace schemas
}  // namespace capnp


typedef ::capnp::schemas::Rgtc_9a59cc24bdd96691 Rgtc;

typedef ::capnp::schemas::Bptc_e7862489f94a0af0 Bptc;

typedef ::capnp::schemas::S3tc_b31f871133cef5fe S3tc;

typedef ::capnp::schemas::BlockSize_a5b0498648f87aab BlockSize;

typedef ::capnp::schemas::Channels_efac83628ed9c608 Channels;

typedef ::capnp::schemas::DataType_bf40f4217973ffde DataType;

struct Uncompressed {
  Uncompressed() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fac0ea8b372b50ff, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::TextureKind_fc05632244f526d5 TextureKind;

struct Texture {
  Texture() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Dimensions;
  struct Compression;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c4cf8d45880f89f2, 3, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Texture::Dimensions {
  Dimensions() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c64972e0022dd9c5, 3, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Texture::Compression {
  Compression() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NONE,
    RGTC,
    BPTC,
    ASTC,
    S3TC,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f81d792693e6a6f3, 3, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Cubemap {
  Cubemap() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ff57f9fd9f83b0d, 0, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct RootTexture {
  RootTexture() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Texture;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8630d6be0dfe5710, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct RootTexture::Texture {
  Texture() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    SINGLE,
    CUBEMAP,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e778d2682349d8fc, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Uncompressed::Reader {
public:
  typedef Uncompressed Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::Channels getFormat() const;

  inline  ::DataType getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Uncompressed::Builder {
public:
  typedef Uncompressed Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::Channels getFormat();
  inline void setFormat( ::Channels value);

  inline  ::DataType getType();
  inline void setType( ::DataType value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Uncompressed::Pipeline {
public:
  typedef Uncompressed Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Texture::Reader {
public:
  typedef Texture Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::TextureKind getKind() const;

  inline Dimensions::Reader getDimensions() const;

  inline bool getSrgb() const;

  inline Compression::Reader getCompression() const;

  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

  inline bool hasMipmaps() const;
  inline  ::capnp::List< ::capnp::Data>::Reader getMipmaps() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Texture::Builder {
public:
  typedef Texture Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::TextureKind getKind();
  inline void setKind( ::TextureKind value);

  inline Dimensions::Builder getDimensions();
  inline Dimensions::Builder initDimensions();

  inline bool getSrgb();
  inline void setSrgb(bool value);

  inline Compression::Builder getCompression();
  inline Compression::Builder initCompression();

  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

  inline bool hasMipmaps();
  inline  ::capnp::List< ::capnp::Data>::Builder getMipmaps();
  inline void setMipmaps( ::capnp::List< ::capnp::Data>::Reader value);
  inline void setMipmaps(::kj::ArrayPtr<const  ::capnp::Data::Reader> value);
  inline  ::capnp::List< ::capnp::Data>::Builder initMipmaps(unsigned int size);
  inline void adoptMipmaps(::capnp::Orphan< ::capnp::List< ::capnp::Data>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Data>> disownMipmaps();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Texture::Pipeline {
public:
  typedef Texture Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline Dimensions::Pipeline getDimensions();
  inline Compression::Pipeline getCompression();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Texture::Dimensions::Reader {
public:
  typedef Dimensions Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getWidth() const;

  inline  ::uint32_t getHeight() const;

  inline  ::uint32_t getDepth() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Texture::Dimensions::Builder {
public:
  typedef Dimensions Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getWidth();
  inline void setWidth( ::uint32_t value);

  inline  ::uint32_t getHeight();
  inline void setHeight( ::uint32_t value);

  inline  ::uint32_t getDepth();
  inline void setDepth( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Texture::Dimensions::Pipeline {
public:
  typedef Dimensions Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Texture::Compression::Reader {
public:
  typedef Compression Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNone() const;
  inline bool hasNone() const;
  inline  ::Uncompressed::Reader getNone() const;

  inline bool isRgtc() const;
  inline  ::Rgtc getRgtc() const;

  inline bool isBptc() const;
  inline  ::Bptc getBptc() const;

  inline bool isAstc() const;
  inline  ::BlockSize getAstc() const;

  inline bool isS3tc() const;
  inline  ::S3tc getS3tc() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Texture::Compression::Builder {
public:
  typedef Compression Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNone();
  inline bool hasNone();
  inline  ::Uncompressed::Builder getNone();
  inline void setNone( ::Uncompressed::Reader value);
  inline  ::Uncompressed::Builder initNone();
  inline void adoptNone(::capnp::Orphan< ::Uncompressed>&& value);
  inline ::capnp::Orphan< ::Uncompressed> disownNone();

  inline bool isRgtc();
  inline  ::Rgtc getRgtc();
  inline void setRgtc( ::Rgtc value);

  inline bool isBptc();
  inline  ::Bptc getBptc();
  inline void setBptc( ::Bptc value);

  inline bool isAstc();
  inline  ::BlockSize getAstc();
  inline void setAstc( ::BlockSize value);

  inline bool isS3tc();
  inline  ::S3tc getS3tc();
  inline void setS3tc( ::S3tc value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Texture::Compression::Pipeline {
public:
  typedef Compression Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cubemap::Reader {
public:
  typedef Cubemap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasRight() const;
  inline  ::Texture::Reader getRight() const;

  inline bool hasLeft() const;
  inline  ::Texture::Reader getLeft() const;

  inline bool hasTop() const;
  inline  ::Texture::Reader getTop() const;

  inline bool hasBottom() const;
  inline  ::Texture::Reader getBottom() const;

  inline bool hasBack() const;
  inline  ::Texture::Reader getBack() const;

  inline bool hasFront() const;
  inline  ::Texture::Reader getFront() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cubemap::Builder {
public:
  typedef Cubemap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRight();
  inline  ::Texture::Builder getRight();
  inline void setRight( ::Texture::Reader value);
  inline  ::Texture::Builder initRight();
  inline void adoptRight(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownRight();

  inline bool hasLeft();
  inline  ::Texture::Builder getLeft();
  inline void setLeft( ::Texture::Reader value);
  inline  ::Texture::Builder initLeft();
  inline void adoptLeft(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownLeft();

  inline bool hasTop();
  inline  ::Texture::Builder getTop();
  inline void setTop( ::Texture::Reader value);
  inline  ::Texture::Builder initTop();
  inline void adoptTop(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownTop();

  inline bool hasBottom();
  inline  ::Texture::Builder getBottom();
  inline void setBottom( ::Texture::Reader value);
  inline  ::Texture::Builder initBottom();
  inline void adoptBottom(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownBottom();

  inline bool hasBack();
  inline  ::Texture::Builder getBack();
  inline void setBack( ::Texture::Reader value);
  inline  ::Texture::Builder initBack();
  inline void adoptBack(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownBack();

  inline bool hasFront();
  inline  ::Texture::Builder getFront();
  inline void setFront( ::Texture::Reader value);
  inline  ::Texture::Builder initFront();
  inline void adoptFront(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownFront();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cubemap::Pipeline {
public:
  typedef Cubemap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Texture::Pipeline getRight();
  inline  ::Texture::Pipeline getLeft();
  inline  ::Texture::Pipeline getTop();
  inline  ::Texture::Pipeline getBottom();
  inline  ::Texture::Pipeline getBack();
  inline  ::Texture::Pipeline getFront();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RootTexture::Reader {
public:
  typedef RootTexture Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Texture::Reader getTexture() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RootTexture::Builder {
public:
  typedef RootTexture Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Texture::Builder getTexture();
  inline Texture::Builder initTexture();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RootTexture::Pipeline {
public:
  typedef RootTexture Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline Texture::Pipeline getTexture();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RootTexture::Texture::Reader {
public:
  typedef Texture Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isSingle() const;
  inline bool hasSingle() const;
  inline  ::Texture::Reader getSingle() const;

  inline bool isCubemap() const;
  inline bool hasCubemap() const;
  inline  ::Cubemap::Reader getCubemap() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RootTexture::Texture::Builder {
public:
  typedef Texture Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isSingle();
  inline bool hasSingle();
  inline  ::Texture::Builder getSingle();
  inline void setSingle( ::Texture::Reader value);
  inline  ::Texture::Builder initSingle();
  inline void adoptSingle(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownSingle();

  inline bool isCubemap();
  inline bool hasCubemap();
  inline  ::Cubemap::Builder getCubemap();
  inline void setCubemap( ::Cubemap::Reader value);
  inline  ::Cubemap::Builder initCubemap();
  inline void adoptCubemap(::capnp::Orphan< ::Cubemap>&& value);
  inline ::capnp::Orphan< ::Cubemap> disownCubemap();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RootTexture::Texture::Pipeline {
public:
  typedef Texture Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::Channels Uncompressed::Reader::getFormat() const {
  return _reader.getDataField< ::Channels>(
      0 * ::capnp::ELEMENTS);
}

inline  ::Channels Uncompressed::Builder::getFormat() {
  return _builder.getDataField< ::Channels>(
      0 * ::capnp::ELEMENTS);
}
inline void Uncompressed::Builder::setFormat( ::Channels value) {
  _builder.setDataField< ::Channels>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::DataType Uncompressed::Reader::getType() const {
  return _reader.getDataField< ::DataType>(
      1 * ::capnp::ELEMENTS);
}

inline  ::DataType Uncompressed::Builder::getType() {
  return _builder.getDataField< ::DataType>(
      1 * ::capnp::ELEMENTS);
}
inline void Uncompressed::Builder::setType( ::DataType value) {
  _builder.setDataField< ::DataType>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::TextureKind Texture::Reader::getKind() const {
  return _reader.getDataField< ::TextureKind>(
      0 * ::capnp::ELEMENTS, 1u);
}

inline  ::TextureKind Texture::Builder::getKind() {
  return _builder.getDataField< ::TextureKind>(
      0 * ::capnp::ELEMENTS, 1u);
}
inline void Texture::Builder::setKind( ::TextureKind value) {
  _builder.setDataField< ::TextureKind>(
      0 * ::capnp::ELEMENTS, value, 1u);
}

inline Texture::Dimensions::Reader Texture::Reader::getDimensions() const {
  return Texture::Dimensions::Reader(_reader);
}
inline Texture::Dimensions::Builder Texture::Builder::getDimensions() {
  return Texture::Dimensions::Builder(_builder);
}
#if !CAPNP_LITE
inline Texture::Dimensions::Pipeline Texture::Pipeline::getDimensions() {
  return Texture::Dimensions::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline Texture::Dimensions::Builder Texture::Builder::initDimensions() {
  _builder.setDataField< ::uint32_t>(1 * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(2 * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(3 * ::capnp::ELEMENTS, 0);
  return Texture::Dimensions::Builder(_builder);
}
inline bool Texture::Reader::getSrgb() const {
  return _reader.getDataField<bool>(
      16 * ::capnp::ELEMENTS);
}

inline bool Texture::Builder::getSrgb() {
  return _builder.getDataField<bool>(
      16 * ::capnp::ELEMENTS);
}
inline void Texture::Builder::setSrgb(bool value) {
  _builder.setDataField<bool>(
      16 * ::capnp::ELEMENTS, value);
}

inline Texture::Compression::Reader Texture::Reader::getCompression() const {
  return Texture::Compression::Reader(_reader);
}
inline Texture::Compression::Builder Texture::Builder::getCompression() {
  return Texture::Compression::Builder(_builder);
}
#if !CAPNP_LITE
inline Texture::Compression::Pipeline Texture::Pipeline::getCompression() {
  return Texture::Compression::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline Texture::Compression::Builder Texture::Builder::initCompression() {
  _builder.setDataField< ::uint16_t>(8 * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(9 * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(0 * ::capnp::POINTERS).clear();
  return Texture::Compression::Builder(_builder);
}
inline bool Texture::Reader::hasData() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Texture::Builder::hasData() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Texture::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Texture::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Texture::Builder::setData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Texture::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void Texture::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Texture::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool Texture::Reader::hasMipmaps() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool Texture::Builder::hasMipmaps() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Data>::Reader Texture::Reader::getMipmaps() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Data>::Builder Texture::Builder::getMipmaps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void Texture::Builder::setMipmaps( ::capnp::List< ::capnp::Data>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline void Texture::Builder::setMipmaps(::kj::ArrayPtr<const  ::capnp::Data::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Data>::Builder Texture::Builder::initMipmaps(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void Texture::Builder::adoptMipmaps(
    ::capnp::Orphan< ::capnp::List< ::capnp::Data>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Data>> Texture::Builder::disownMipmaps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline  ::uint32_t Texture::Dimensions::Reader::getWidth() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Texture::Dimensions::Builder::getWidth() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Texture::Dimensions::Builder::setWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Texture::Dimensions::Reader::getHeight() const {
  return _reader.getDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Texture::Dimensions::Builder::getHeight() {
  return _builder.getDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS);
}
inline void Texture::Dimensions::Builder::setHeight( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Texture::Dimensions::Reader::getDepth() const {
  return _reader.getDataField< ::uint32_t>(
      3 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Texture::Dimensions::Builder::getDepth() {
  return _builder.getDataField< ::uint32_t>(
      3 * ::capnp::ELEMENTS);
}
inline void Texture::Dimensions::Builder::setDepth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::Texture::Compression::Which Texture::Compression::Reader::which() const {
  return _reader.getDataField<Which>(8 * ::capnp::ELEMENTS);
}
inline  ::Texture::Compression::Which Texture::Compression::Builder::which() {
  return _builder.getDataField<Which>(8 * ::capnp::ELEMENTS);
}

inline bool Texture::Compression::Reader::isNone() const {
  return which() == Texture::Compression::NONE;
}
inline bool Texture::Compression::Builder::isNone() {
  return which() == Texture::Compression::NONE;
}
inline bool Texture::Compression::Reader::hasNone() const {
  if (which() != Texture::Compression::NONE) return false;
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Texture::Compression::Builder::hasNone() {
  if (which() != Texture::Compression::NONE) return false;
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::Uncompressed::Reader Texture::Compression::Reader::getNone() const {
  KJ_IREQUIRE(which() == Texture::Compression::NONE,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Uncompressed>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Uncompressed::Builder Texture::Compression::Builder::getNone() {
  KJ_IREQUIRE(which() == Texture::Compression::NONE,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Uncompressed>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Texture::Compression::Builder::setNone( ::Uncompressed::Reader value) {
  _builder.setDataField<Texture::Compression::Which>(
      8 * ::capnp::ELEMENTS, Texture::Compression::NONE);
  ::capnp::_::PointerHelpers< ::Uncompressed>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::Uncompressed::Builder Texture::Compression::Builder::initNone() {
  _builder.setDataField<Texture::Compression::Which>(
      8 * ::capnp::ELEMENTS, Texture::Compression::NONE);
  return ::capnp::_::PointerHelpers< ::Uncompressed>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Texture::Compression::Builder::adoptNone(
    ::capnp::Orphan< ::Uncompressed>&& value) {
  _builder.setDataField<Texture::Compression::Which>(
      8 * ::capnp::ELEMENTS, Texture::Compression::NONE);
  ::capnp::_::PointerHelpers< ::Uncompressed>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Uncompressed> Texture::Compression::Builder::disownNone() {
  KJ_IREQUIRE(which() == Texture::Compression::NONE,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Uncompressed>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Texture::Compression::Reader::isRgtc() const {
  return which() == Texture::Compression::RGTC;
}
inline bool Texture::Compression::Builder::isRgtc() {
  return which() == Texture::Compression::RGTC;
}
inline  ::Rgtc Texture::Compression::Reader::getRgtc() const {
  KJ_IREQUIRE(which() == Texture::Compression::RGTC,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::Rgtc>(
      9 * ::capnp::ELEMENTS);
}

inline  ::Rgtc Texture::Compression::Builder::getRgtc() {
  KJ_IREQUIRE(which() == Texture::Compression::RGTC,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::Rgtc>(
      9 * ::capnp::ELEMENTS);
}
inline void Texture::Compression::Builder::setRgtc( ::Rgtc value) {
  _builder.setDataField<Texture::Compression::Which>(
      8 * ::capnp::ELEMENTS, Texture::Compression::RGTC);
  _builder.setDataField< ::Rgtc>(
      9 * ::capnp::ELEMENTS, value);
}

inline bool Texture::Compression::Reader::isBptc() const {
  return which() == Texture::Compression::BPTC;
}
inline bool Texture::Compression::Builder::isBptc() {
  return which() == Texture::Compression::BPTC;
}
inline  ::Bptc Texture::Compression::Reader::getBptc() const {
  KJ_IREQUIRE(which() == Texture::Compression::BPTC,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::Bptc>(
      9 * ::capnp::ELEMENTS);
}

inline  ::Bptc Texture::Compression::Builder::getBptc() {
  KJ_IREQUIRE(which() == Texture::Compression::BPTC,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::Bptc>(
      9 * ::capnp::ELEMENTS);
}
inline void Texture::Compression::Builder::setBptc( ::Bptc value) {
  _builder.setDataField<Texture::Compression::Which>(
      8 * ::capnp::ELEMENTS, Texture::Compression::BPTC);
  _builder.setDataField< ::Bptc>(
      9 * ::capnp::ELEMENTS, value);
}

inline bool Texture::Compression::Reader::isAstc() const {
  return which() == Texture::Compression::ASTC;
}
inline bool Texture::Compression::Builder::isAstc() {
  return which() == Texture::Compression::ASTC;
}
inline  ::BlockSize Texture::Compression::Reader::getAstc() const {
  KJ_IREQUIRE(which() == Texture::Compression::ASTC,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::BlockSize>(
      9 * ::capnp::ELEMENTS);
}

inline  ::BlockSize Texture::Compression::Builder::getAstc() {
  KJ_IREQUIRE(which() == Texture::Compression::ASTC,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::BlockSize>(
      9 * ::capnp::ELEMENTS);
}
inline void Texture::Compression::Builder::setAstc( ::BlockSize value) {
  _builder.setDataField<Texture::Compression::Which>(
      8 * ::capnp::ELEMENTS, Texture::Compression::ASTC);
  _builder.setDataField< ::BlockSize>(
      9 * ::capnp::ELEMENTS, value);
}

inline bool Texture::Compression::Reader::isS3tc() const {
  return which() == Texture::Compression::S3TC;
}
inline bool Texture::Compression::Builder::isS3tc() {
  return which() == Texture::Compression::S3TC;
}
inline  ::S3tc Texture::Compression::Reader::getS3tc() const {
  KJ_IREQUIRE(which() == Texture::Compression::S3TC,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::S3tc>(
      9 * ::capnp::ELEMENTS);
}

inline  ::S3tc Texture::Compression::Builder::getS3tc() {
  KJ_IREQUIRE(which() == Texture::Compression::S3TC,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::S3tc>(
      9 * ::capnp::ELEMENTS);
}
inline void Texture::Compression::Builder::setS3tc( ::S3tc value) {
  _builder.setDataField<Texture::Compression::Which>(
      8 * ::capnp::ELEMENTS, Texture::Compression::S3TC);
  _builder.setDataField< ::S3tc>(
      9 * ::capnp::ELEMENTS, value);
}

inline bool Cubemap::Reader::hasRight() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasRight() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getRight() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getRight() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getRight() {
  return  ::Texture::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setRight( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initRight() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptRight(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownRight() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Cubemap::Reader::hasLeft() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasLeft() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getLeft() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getLeft() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getLeft() {
  return  ::Texture::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setLeft( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initLeft() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptLeft(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownLeft() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool Cubemap::Reader::hasTop() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasTop() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getTop() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getTop() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getTop() {
  return  ::Texture::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setTop( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initTop() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptTop(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownTop() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool Cubemap::Reader::hasBottom() const {
  return !_reader.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasBottom() {
  return !_builder.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getBottom() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(3 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getBottom() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getBottom() {
  return  ::Texture::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setBottom( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(3 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initBottom() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptBottom(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(3 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownBottom() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}

inline bool Cubemap::Reader::hasBack() const {
  return !_reader.getPointerField(4 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasBack() {
  return !_builder.getPointerField(4 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getBack() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(4 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getBack() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getBack() {
  return  ::Texture::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setBack( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(4 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initBack() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptBack(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(4 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownBack() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}

inline bool Cubemap::Reader::hasFront() const {
  return !_reader.getPointerField(5 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasFront() {
  return !_builder.getPointerField(5 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getFront() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(5 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getFront() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(5 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getFront() {
  return  ::Texture::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setFront( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(5 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initFront() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(5 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptFront(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(5 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownFront() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(5 * ::capnp::POINTERS));
}

inline RootTexture::Texture::Reader RootTexture::Reader::getTexture() const {
  return RootTexture::Texture::Reader(_reader);
}
inline RootTexture::Texture::Builder RootTexture::Builder::getTexture() {
  return RootTexture::Texture::Builder(_builder);
}
#if !CAPNP_LITE
inline RootTexture::Texture::Pipeline RootTexture::Pipeline::getTexture() {
  return RootTexture::Texture::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline RootTexture::Texture::Builder RootTexture::Builder::initTexture() {
  _builder.setDataField< ::uint16_t>(0 * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(0 * ::capnp::POINTERS).clear();
  return RootTexture::Texture::Builder(_builder);
}
inline  ::RootTexture::Texture::Which RootTexture::Texture::Reader::which() const {
  return _reader.getDataField<Which>(0 * ::capnp::ELEMENTS);
}
inline  ::RootTexture::Texture::Which RootTexture::Texture::Builder::which() {
  return _builder.getDataField<Which>(0 * ::capnp::ELEMENTS);
}

inline bool RootTexture::Texture::Reader::isSingle() const {
  return which() == RootTexture::Texture::SINGLE;
}
inline bool RootTexture::Texture::Builder::isSingle() {
  return which() == RootTexture::Texture::SINGLE;
}
inline bool RootTexture::Texture::Reader::hasSingle() const {
  if (which() != RootTexture::Texture::SINGLE) return false;
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool RootTexture::Texture::Builder::hasSingle() {
  if (which() != RootTexture::Texture::SINGLE) return false;
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader RootTexture::Texture::Reader::getSingle() const {
  KJ_IREQUIRE(which() == RootTexture::Texture::SINGLE,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Texture::Builder RootTexture::Texture::Builder::getSingle() {
  KJ_IREQUIRE(which() == RootTexture::Texture::SINGLE,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void RootTexture::Texture::Builder::setSingle( ::Texture::Reader value) {
  _builder.setDataField<RootTexture::Texture::Which>(
      0 * ::capnp::ELEMENTS, RootTexture::Texture::SINGLE);
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder RootTexture::Texture::Builder::initSingle() {
  _builder.setDataField<RootTexture::Texture::Which>(
      0 * ::capnp::ELEMENTS, RootTexture::Texture::SINGLE);
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void RootTexture::Texture::Builder::adoptSingle(
    ::capnp::Orphan< ::Texture>&& value) {
  _builder.setDataField<RootTexture::Texture::Which>(
      0 * ::capnp::ELEMENTS, RootTexture::Texture::SINGLE);
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> RootTexture::Texture::Builder::disownSingle() {
  KJ_IREQUIRE(which() == RootTexture::Texture::SINGLE,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool RootTexture::Texture::Reader::isCubemap() const {
  return which() == RootTexture::Texture::CUBEMAP;
}
inline bool RootTexture::Texture::Builder::isCubemap() {
  return which() == RootTexture::Texture::CUBEMAP;
}
inline bool RootTexture::Texture::Reader::hasCubemap() const {
  if (which() != RootTexture::Texture::CUBEMAP) return false;
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool RootTexture::Texture::Builder::hasCubemap() {
  if (which() != RootTexture::Texture::CUBEMAP) return false;
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::Cubemap::Reader RootTexture::Texture::Reader::getCubemap() const {
  KJ_IREQUIRE(which() == RootTexture::Texture::CUBEMAP,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Cubemap>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Cubemap::Builder RootTexture::Texture::Builder::getCubemap() {
  KJ_IREQUIRE(which() == RootTexture::Texture::CUBEMAP,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Cubemap>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void RootTexture::Texture::Builder::setCubemap( ::Cubemap::Reader value) {
  _builder.setDataField<RootTexture::Texture::Which>(
      0 * ::capnp::ELEMENTS, RootTexture::Texture::CUBEMAP);
  ::capnp::_::PointerHelpers< ::Cubemap>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::Cubemap::Builder RootTexture::Texture::Builder::initCubemap() {
  _builder.setDataField<RootTexture::Texture::Which>(
      0 * ::capnp::ELEMENTS, RootTexture::Texture::CUBEMAP);
  return ::capnp::_::PointerHelpers< ::Cubemap>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void RootTexture::Texture::Builder::adoptCubemap(
    ::capnp::Orphan< ::Cubemap>&& value) {
  _builder.setDataField<RootTexture::Texture::Which>(
      0 * ::capnp::ELEMENTS, RootTexture::Texture::CUBEMAP);
  ::capnp::_::PointerHelpers< ::Cubemap>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Cubemap> RootTexture::Texture::Builder::disownCubemap() {
  KJ_IREQUIRE(which() == RootTexture::Texture::CUBEMAP,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Cubemap>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}


#endif  // CAPNP_INCLUDED_a0647fd03678a3a6_
