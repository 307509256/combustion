// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: protocols\texture.capnp

#ifndef CAPNP_INCLUDED_a0647fd03678a3a6_
#define CAPNP_INCLUDED_a0647fd03678a3a6_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 5003
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(9a59cc24bdd96691);
enum class Rgtc_9a59cc24bdd96691: uint16_t {
  RED,
  RED_SIGNED,
  RG,
  RG_SIGNED,
};
CAPNP_DECLARE_ENUM(Rgtc, 9a59cc24bdd96691);
CAPNP_DECLARE_SCHEMA(e7862489f94a0af0);
enum class Bptc_e7862489f94a0af0: uint16_t {
  RGBA,
  RGB_FLOAT_SIGNED,
  RGB_FLOAT_UNSIGNED,
};
CAPNP_DECLARE_ENUM(Bptc, e7862489f94a0af0);
CAPNP_DECLARE_SCHEMA(b31f871133cef5fe);
enum class S3tc_b31f871133cef5fe: uint16_t {
  RGB1,
  RGBA1,
  RGBA3,
  RGBA5,
};
CAPNP_DECLARE_ENUM(S3tc, b31f871133cef5fe);
CAPNP_DECLARE_SCHEMA(a5b0498648f87aab);
enum class BlockSize_a5b0498648f87aab: uint16_t {
  B4X4,
  B5X4,
  B5X5,
  B6X5,
  B6X6,
  B8X5,
  B8X6,
  B10X5,
  B10X6,
  B8X8,
  B10X8,
  B10X10,
  B12X10,
  B12X12,
};
CAPNP_DECLARE_ENUM(BlockSize, a5b0498648f87aab);
CAPNP_DECLARE_SCHEMA(8315320b3b27faa1);
enum class Raw_8315320b3b27faa1: uint16_t {
  R,
  RG,
  RGB,
  RGBA,
};
CAPNP_DECLARE_ENUM(Raw, 8315320b3b27faa1);
CAPNP_DECLARE_SCHEMA(ce85a5aed9db9382);
enum class Kind_ce85a5aed9db9382: uint16_t {
  TEXTURE1_D,
  TEXTURE2_D,
  TEXTURE3_D,
};
CAPNP_DECLARE_ENUM(Kind, ce85a5aed9db9382);
CAPNP_DECLARE_SCHEMA(c4cf8d45880f89f2);
CAPNP_DECLARE_SCHEMA(88a85f661c059e3d);
CAPNP_DECLARE_SCHEMA(9ff57f9fd9f83b0d);

}  // namespace schemas
}  // namespace capnp


typedef ::capnp::schemas::Rgtc_9a59cc24bdd96691 Rgtc;

typedef ::capnp::schemas::Bptc_e7862489f94a0af0 Bptc;

typedef ::capnp::schemas::S3tc_b31f871133cef5fe S3tc;

typedef ::capnp::schemas::BlockSize_a5b0498648f87aab BlockSize;

typedef ::capnp::schemas::Raw_8315320b3b27faa1 Raw;

typedef ::capnp::schemas::Kind_ce85a5aed9db9382 Kind;

struct Texture {
  Texture() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Compression;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c4cf8d45880f89f2, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Texture::Compression {
  Compression() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NONE,
    RGTC,
    BPTC,
    ASTC,
    S3TC,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(88a85f661c059e3d, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Cubemap {
  Cubemap() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ff57f9fd9f83b0d, 0, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Texture::Reader {
public:
  typedef Texture Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getWidth() const;

  inline  ::uint32_t getHeight() const;

  inline Compression::Reader getCompression() const;

  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

  inline bool getSrgb() const;

  inline  ::uint32_t getDepth() const;

  inline  ::Kind getKind() const;

  inline bool hasMipmaps() const;
  inline  ::capnp::List< ::capnp::Data>::Reader getMipmaps() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Texture::Builder {
public:
  typedef Texture Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getWidth();
  inline void setWidth( ::uint32_t value);

  inline  ::uint32_t getHeight();
  inline void setHeight( ::uint32_t value);

  inline Compression::Builder getCompression();
  inline Compression::Builder initCompression();

  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

  inline bool getSrgb();
  inline void setSrgb(bool value);

  inline  ::uint32_t getDepth();
  inline void setDepth( ::uint32_t value);

  inline  ::Kind getKind();
  inline void setKind( ::Kind value);

  inline bool hasMipmaps();
  inline  ::capnp::List< ::capnp::Data>::Builder getMipmaps();
  inline void setMipmaps( ::capnp::List< ::capnp::Data>::Reader value);
  inline void setMipmaps(::kj::ArrayPtr<const  ::capnp::Data::Reader> value);
  inline  ::capnp::List< ::capnp::Data>::Builder initMipmaps(unsigned int size);
  inline void adoptMipmaps(::capnp::Orphan< ::capnp::List< ::capnp::Data>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Data>> disownMipmaps();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Texture::Pipeline {
public:
  typedef Texture Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline Compression::Pipeline getCompression();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Texture::Compression::Reader {
public:
  typedef Compression Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNone() const;
  inline  ::Raw getNone() const;

  inline bool isRgtc() const;
  inline  ::Rgtc getRgtc() const;

  inline bool isBptc() const;
  inline  ::Bptc getBptc() const;

  inline bool isAstc() const;
  inline  ::BlockSize getAstc() const;

  inline bool isS3tc() const;
  inline  ::S3tc getS3tc() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Texture::Compression::Builder {
public:
  typedef Compression Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNone();
  inline  ::Raw getNone();
  inline void setNone( ::Raw value);

  inline bool isRgtc();
  inline  ::Rgtc getRgtc();
  inline void setRgtc( ::Rgtc value);

  inline bool isBptc();
  inline  ::Bptc getBptc();
  inline void setBptc( ::Bptc value);

  inline bool isAstc();
  inline  ::BlockSize getAstc();
  inline void setAstc( ::BlockSize value);

  inline bool isS3tc();
  inline  ::S3tc getS3tc();
  inline void setS3tc( ::S3tc value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Texture::Compression::Pipeline {
public:
  typedef Compression Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cubemap::Reader {
public:
  typedef Cubemap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasRight() const;
  inline  ::Texture::Reader getRight() const;

  inline bool hasLeft() const;
  inline  ::Texture::Reader getLeft() const;

  inline bool hasTop() const;
  inline  ::Texture::Reader getTop() const;

  inline bool hasBottom() const;
  inline  ::Texture::Reader getBottom() const;

  inline bool hasBack() const;
  inline  ::Texture::Reader getBack() const;

  inline bool hasFront() const;
  inline  ::Texture::Reader getFront() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cubemap::Builder {
public:
  typedef Cubemap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRight();
  inline  ::Texture::Builder getRight();
  inline void setRight( ::Texture::Reader value);
  inline  ::Texture::Builder initRight();
  inline void adoptRight(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownRight();

  inline bool hasLeft();
  inline  ::Texture::Builder getLeft();
  inline void setLeft( ::Texture::Reader value);
  inline  ::Texture::Builder initLeft();
  inline void adoptLeft(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownLeft();

  inline bool hasTop();
  inline  ::Texture::Builder getTop();
  inline void setTop( ::Texture::Reader value);
  inline  ::Texture::Builder initTop();
  inline void adoptTop(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownTop();

  inline bool hasBottom();
  inline  ::Texture::Builder getBottom();
  inline void setBottom( ::Texture::Reader value);
  inline  ::Texture::Builder initBottom();
  inline void adoptBottom(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownBottom();

  inline bool hasBack();
  inline  ::Texture::Builder getBack();
  inline void setBack( ::Texture::Reader value);
  inline  ::Texture::Builder initBack();
  inline void adoptBack(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownBack();

  inline bool hasFront();
  inline  ::Texture::Builder getFront();
  inline void setFront( ::Texture::Reader value);
  inline  ::Texture::Builder initFront();
  inline void adoptFront(::capnp::Orphan< ::Texture>&& value);
  inline ::capnp::Orphan< ::Texture> disownFront();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cubemap::Pipeline {
public:
  typedef Cubemap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Texture::Pipeline getRight();
  inline  ::Texture::Pipeline getLeft();
  inline  ::Texture::Pipeline getTop();
  inline  ::Texture::Pipeline getBottom();
  inline  ::Texture::Pipeline getBack();
  inline  ::Texture::Pipeline getFront();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint32_t Texture::Reader::getWidth() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Texture::Builder::getWidth() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Texture::Builder::setWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Texture::Reader::getHeight() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Texture::Builder::getHeight() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Texture::Builder::setHeight( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline Texture::Compression::Reader Texture::Reader::getCompression() const {
  return Texture::Compression::Reader(_reader);
}
inline Texture::Compression::Builder Texture::Builder::getCompression() {
  return Texture::Compression::Builder(_builder);
}
#if !CAPNP_LITE
inline Texture::Compression::Pipeline Texture::Pipeline::getCompression() {
  return Texture::Compression::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline Texture::Compression::Builder Texture::Builder::initCompression() {
  _builder.setDataField< ::uint16_t>(4 * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(5 * ::capnp::ELEMENTS, 0);
  return Texture::Compression::Builder(_builder);
}
inline bool Texture::Reader::hasData() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Texture::Builder::hasData() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Texture::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Texture::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Texture::Builder::setData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Texture::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Texture::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Texture::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Texture::Reader::getSrgb() const {
  return _reader.getDataField<bool>(
      96 * ::capnp::ELEMENTS);
}

inline bool Texture::Builder::getSrgb() {
  return _builder.getDataField<bool>(
      96 * ::capnp::ELEMENTS);
}
inline void Texture::Builder::setSrgb(bool value) {
  _builder.setDataField<bool>(
      96 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Texture::Reader::getDepth() const {
  return _reader.getDataField< ::uint32_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Texture::Builder::getDepth() {
  return _builder.getDataField< ::uint32_t>(
      4 * ::capnp::ELEMENTS);
}
inline void Texture::Builder::setDepth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline  ::Kind Texture::Reader::getKind() const {
  return _reader.getDataField< ::Kind>(
      7 * ::capnp::ELEMENTS, 1u);
}

inline  ::Kind Texture::Builder::getKind() {
  return _builder.getDataField< ::Kind>(
      7 * ::capnp::ELEMENTS, 1u);
}
inline void Texture::Builder::setKind( ::Kind value) {
  _builder.setDataField< ::Kind>(
      7 * ::capnp::ELEMENTS, value, 1u);
}

inline bool Texture::Reader::hasMipmaps() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Texture::Builder::hasMipmaps() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Data>::Reader Texture::Reader::getMipmaps() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Data>::Builder Texture::Builder::getMipmaps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Texture::Builder::setMipmaps( ::capnp::List< ::capnp::Data>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline void Texture::Builder::setMipmaps(::kj::ArrayPtr<const  ::capnp::Data::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Data>::Builder Texture::Builder::initMipmaps(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void Texture::Builder::adoptMipmaps(
    ::capnp::Orphan< ::capnp::List< ::capnp::Data>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Data>> Texture::Builder::disownMipmaps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::Texture::Compression::Which Texture::Compression::Reader::which() const {
  return _reader.getDataField<Which>(5 * ::capnp::ELEMENTS);
}
inline  ::Texture::Compression::Which Texture::Compression::Builder::which() {
  return _builder.getDataField<Which>(5 * ::capnp::ELEMENTS);
}

inline bool Texture::Compression::Reader::isNone() const {
  return which() == Texture::Compression::NONE;
}
inline bool Texture::Compression::Builder::isNone() {
  return which() == Texture::Compression::NONE;
}
inline  ::Raw Texture::Compression::Reader::getNone() const {
  KJ_IREQUIRE(which() == Texture::Compression::NONE,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::Raw>(
      4 * ::capnp::ELEMENTS);
}

inline  ::Raw Texture::Compression::Builder::getNone() {
  KJ_IREQUIRE(which() == Texture::Compression::NONE,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::Raw>(
      4 * ::capnp::ELEMENTS);
}
inline void Texture::Compression::Builder::setNone( ::Raw value) {
  _builder.setDataField<Texture::Compression::Which>(
      5 * ::capnp::ELEMENTS, Texture::Compression::NONE);
  _builder.setDataField< ::Raw>(
      4 * ::capnp::ELEMENTS, value);
}

inline bool Texture::Compression::Reader::isRgtc() const {
  return which() == Texture::Compression::RGTC;
}
inline bool Texture::Compression::Builder::isRgtc() {
  return which() == Texture::Compression::RGTC;
}
inline  ::Rgtc Texture::Compression::Reader::getRgtc() const {
  KJ_IREQUIRE(which() == Texture::Compression::RGTC,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::Rgtc>(
      4 * ::capnp::ELEMENTS);
}

inline  ::Rgtc Texture::Compression::Builder::getRgtc() {
  KJ_IREQUIRE(which() == Texture::Compression::RGTC,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::Rgtc>(
      4 * ::capnp::ELEMENTS);
}
inline void Texture::Compression::Builder::setRgtc( ::Rgtc value) {
  _builder.setDataField<Texture::Compression::Which>(
      5 * ::capnp::ELEMENTS, Texture::Compression::RGTC);
  _builder.setDataField< ::Rgtc>(
      4 * ::capnp::ELEMENTS, value);
}

inline bool Texture::Compression::Reader::isBptc() const {
  return which() == Texture::Compression::BPTC;
}
inline bool Texture::Compression::Builder::isBptc() {
  return which() == Texture::Compression::BPTC;
}
inline  ::Bptc Texture::Compression::Reader::getBptc() const {
  KJ_IREQUIRE(which() == Texture::Compression::BPTC,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::Bptc>(
      4 * ::capnp::ELEMENTS);
}

inline  ::Bptc Texture::Compression::Builder::getBptc() {
  KJ_IREQUIRE(which() == Texture::Compression::BPTC,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::Bptc>(
      4 * ::capnp::ELEMENTS);
}
inline void Texture::Compression::Builder::setBptc( ::Bptc value) {
  _builder.setDataField<Texture::Compression::Which>(
      5 * ::capnp::ELEMENTS, Texture::Compression::BPTC);
  _builder.setDataField< ::Bptc>(
      4 * ::capnp::ELEMENTS, value);
}

inline bool Texture::Compression::Reader::isAstc() const {
  return which() == Texture::Compression::ASTC;
}
inline bool Texture::Compression::Builder::isAstc() {
  return which() == Texture::Compression::ASTC;
}
inline  ::BlockSize Texture::Compression::Reader::getAstc() const {
  KJ_IREQUIRE(which() == Texture::Compression::ASTC,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::BlockSize>(
      4 * ::capnp::ELEMENTS);
}

inline  ::BlockSize Texture::Compression::Builder::getAstc() {
  KJ_IREQUIRE(which() == Texture::Compression::ASTC,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::BlockSize>(
      4 * ::capnp::ELEMENTS);
}
inline void Texture::Compression::Builder::setAstc( ::BlockSize value) {
  _builder.setDataField<Texture::Compression::Which>(
      5 * ::capnp::ELEMENTS, Texture::Compression::ASTC);
  _builder.setDataField< ::BlockSize>(
      4 * ::capnp::ELEMENTS, value);
}

inline bool Texture::Compression::Reader::isS3tc() const {
  return which() == Texture::Compression::S3TC;
}
inline bool Texture::Compression::Builder::isS3tc() {
  return which() == Texture::Compression::S3TC;
}
inline  ::S3tc Texture::Compression::Reader::getS3tc() const {
  KJ_IREQUIRE(which() == Texture::Compression::S3TC,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::S3tc>(
      4 * ::capnp::ELEMENTS);
}

inline  ::S3tc Texture::Compression::Builder::getS3tc() {
  KJ_IREQUIRE(which() == Texture::Compression::S3TC,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::S3tc>(
      4 * ::capnp::ELEMENTS);
}
inline void Texture::Compression::Builder::setS3tc( ::S3tc value) {
  _builder.setDataField<Texture::Compression::Which>(
      5 * ::capnp::ELEMENTS, Texture::Compression::S3TC);
  _builder.setDataField< ::S3tc>(
      4 * ::capnp::ELEMENTS, value);
}

inline bool Cubemap::Reader::hasRight() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasRight() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getRight() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getRight() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getRight() {
  return  ::Texture::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setRight( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initRight() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptRight(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownRight() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Cubemap::Reader::hasLeft() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasLeft() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getLeft() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getLeft() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getLeft() {
  return  ::Texture::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setLeft( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initLeft() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptLeft(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownLeft() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool Cubemap::Reader::hasTop() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasTop() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getTop() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getTop() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getTop() {
  return  ::Texture::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setTop( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initTop() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptTop(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownTop() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool Cubemap::Reader::hasBottom() const {
  return !_reader.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasBottom() {
  return !_builder.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getBottom() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(3 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getBottom() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getBottom() {
  return  ::Texture::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setBottom( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(3 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initBottom() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptBottom(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(3 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownBottom() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}

inline bool Cubemap::Reader::hasBack() const {
  return !_reader.getPointerField(4 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasBack() {
  return !_builder.getPointerField(4 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getBack() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(4 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getBack() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getBack() {
  return  ::Texture::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setBack( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(4 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initBack() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptBack(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(4 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownBack() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}

inline bool Cubemap::Reader::hasFront() const {
  return !_reader.getPointerField(5 * ::capnp::POINTERS).isNull();
}
inline bool Cubemap::Builder::hasFront() {
  return !_builder.getPointerField(5 * ::capnp::POINTERS).isNull();
}
inline  ::Texture::Reader Cubemap::Reader::getFront() const {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _reader.getPointerField(5 * ::capnp::POINTERS));
}
inline  ::Texture::Builder Cubemap::Builder::getFront() {
  return ::capnp::_::PointerHelpers< ::Texture>::get(
      _builder.getPointerField(5 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Texture::Pipeline Cubemap::Pipeline::getFront() {
  return  ::Texture::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void Cubemap::Builder::setFront( ::Texture::Reader value) {
  ::capnp::_::PointerHelpers< ::Texture>::set(
      _builder.getPointerField(5 * ::capnp::POINTERS), value);
}
inline  ::Texture::Builder Cubemap::Builder::initFront() {
  return ::capnp::_::PointerHelpers< ::Texture>::init(
      _builder.getPointerField(5 * ::capnp::POINTERS));
}
inline void Cubemap::Builder::adoptFront(
    ::capnp::Orphan< ::Texture>&& value) {
  ::capnp::_::PointerHelpers< ::Texture>::adopt(
      _builder.getPointerField(5 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Texture> Cubemap::Builder::disownFront() {
  return ::capnp::_::PointerHelpers< ::Texture>::disown(
      _builder.getPointerField(5 * ::capnp::POINTERS));
}


#endif  // CAPNP_INCLUDED_a0647fd03678a3a6_
